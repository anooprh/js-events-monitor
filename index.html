<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript Events Monitor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    h1 {
      color: #4CAF50;
      margin-bottom: 10px;
      font-size: 24px;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 8px 16px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 6px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #3d3d3d;
    }
    
    button.active {
      background: #4CAF50;
      border-color: #4CAF50;
    }
    
    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      font-size: 12px;
      color: #aaa;
    }
    
    .stats span {
      padding: 4px 8px;
      background: #2d2d2d;
      border-radius: 4px;
    }
    
    .event-log {
      flex: 1;
      overflow-y: auto;
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
    }
    
    .event-item {
      margin-bottom: 8px;
      padding: 8px;
      border-left: 3px solid #333;
      background: #151515;
      border-radius: 4px;
      animation: fadeIn 0.2s;
      position: relative;
    }
    
    .event-item:hover {
      background: #1a1a1a;
      border-left-color: #4CAF50;
    }

    .event-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .event-count-badge {
      display: inline-block;
      background: #4CAF50;
      color: #fff;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 8px;
      vertical-align: middle;
    }
    
    .event-item-grouped {
      border-left-color: #4CAF50;
    }

    .event-item-expanded .event-raw-toggle {
      background: #4CAF50;
      border-color: #4CAF50;
      color: #0f0f0f;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .event-time {
      color: #888;
      font-size: 10px;
      margin-right: 8px;
    }
    
    .event-type {
      color: #4CAF50;
      font-weight: bold;
      margin-right: 8px;
    }
    
    .event-details {
      color: #bbb;
      margin-top: 4px;
      padding-left: 20px;
      font-size: 11px;
    }
    
    .event-details pre {
      margin: 4px 0;
      color: #888;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .event-raw-toggle {
      margin-left: auto;
      padding: 2px 8px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 10px;
      transition: background 0.2s, border-color 0.2s;
    }

    .event-raw-toggle:hover {
      background: #3d3d3d;
      border-color: #555;
    }

    .event-raw {
      margin-top: 8px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #0b0b0b;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 11px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .filter-input {
      padding: 8px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      width: 200px;
    }
    
    .filter-input:focus {
      outline: none;
      border-color: #4CAF50;
    }
    
    .scrollbar {
      scrollbar-width: thin;
      scrollbar-color: #444 #0f0f0f;
    }
    
    .scrollbar::-webkit-scrollbar {
      width: 8px;
    }
    
    .scrollbar::-webkit-scrollbar-track {
      background: #0f0f0f;
    }
    
    .scrollbar::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    
    .scrollbar::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    /* Filter panel */
    .filter-panel {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
      max-height: 500px;
      overflow: hidden;
    }
    
    .filter-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid #333;
      flex-shrink: 0;
      background: #1a1a1a;
      gap: 12px;
    }
    
    .filter-panel-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      cursor: pointer;
    }
    
    .filter-panel-header h3 {
      margin: 0;
      font-size: 16px;
      color: #4CAF50;
    }
    
    .filter-panel-toggle {
      font-size: 12px;
      color: #888;
      transition: color 0.2s;
    }
    
    .filter-actions {
      display: flex;
      gap: 8px;
    }
    
    .filter-action-btn {
      padding: 6px 12px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }
    
    .filter-action-btn:hover {
      background: #3d3d3d;
    }
    
    .filter-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 16px;
      min-height: 0;
    }
    
    .filter-content.scrollbar {
      scrollbar-width: thin;
      scrollbar-color: #444 #0f0f0f;
    }
    
    .filter-content.scrollbar::-webkit-scrollbar {
      width: 8px;
    }
    
    .filter-content.scrollbar::-webkit-scrollbar-track {
      background: #0f0f0f;
    }
    
    .filter-content.scrollbar::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    
    .filter-content.scrollbar::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    /* Resize handle */
    .filter-resize-handle {
      height: 4px;
      background: #333;
      cursor: ns-resize;
      flex-shrink: 0;
      position: relative;
      transition: background 0.2s;
    }
    
    .filter-resize-handle:hover {
      background: #4CAF50;
    }
    
    .filter-resize-handle::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 2px;
      background: #555;
      border-radius: 2px;
    }
    
    .filter-resize-handle:hover::after {
      background: #4CAF50;
    }
    
    .filter-panel.collapsed .filter-content {
      display: none;
    }
    
    .filter-panel.collapsed .filter-resize-handle {
      display: none;
    }
    
    .filter-sections {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .filter-section {
      border: 1px solid #333;
      border-radius: 6px;
      background: #151515;
      overflow: visible;
    }
    
    .filter-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #1f1f1f;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      gap: 12px;
    }
    
    .filter-section-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    
    .filter-section-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    
    .filter-section-action-btn {
      padding: 4px 8px;
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 10px;
      transition: background 0.2s;
      white-space: nowrap;
    }
    
    .filter-section-action-btn:hover {
      background: #3d3d3d;
    }
    
    .filter-section-header h4 {
      margin: 0;
      flex: 0 0 auto;
    }
    
    .filter-section-header:hover {
      background: #252525;
    }
    
    
    .filter-section-toggle {
      font-size: 12px;
      color: #888;
      transition: color 0.2s;
    }
    
    .filter-section-content {
      display: none;
      padding: 12px;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 8px;
    }
    
    .filter-section.expanded .filter-section-content {
      display: grid;
    }
    
    .filter-checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s;
    }
    
    .filter-checkbox-item:hover {
      background: #252525;
    }
    
    .filter-checkbox-item input[type="checkbox"] {
      cursor: pointer;
      width: 16px;
      height: 16px;
      accent-color: #4CAF50;
    }
    
    .filter-checkbox-item label {
      cursor: pointer;
      font-size: 12px;
      color: #e0e0e0;
      user-select: none;
    }
  </style>
</head>
<body>
  <h1>JavaScript Events Monitor</h1>
  
  <div class="controls">
    <button id="clearBtn">Clear Log</button>
    <button id="pauseBtn">Pause</button>
    <button id="exportBtn">Export Log</button>
  </div>
  
  <div class="filter-panel" id="filterPanel">
    <div class="filter-panel-header" id="filterPanelHeader">
      <div class="filter-panel-header-left">
        <h3>Select Events to Include</h3>
        <span class="filter-panel-toggle" id="filterPanelToggle">▼</span>
      </div>
      <div class="filter-actions">
        <button id="selectAllBtn" class="filter-action-btn">Enable All</button>
        <button id="selectNoneBtn" class="filter-action-btn">Disable All</button>
      </div>
    </div>
    <div class="filter-content scrollbar" id="filterContent">
      <div class="filter-sections" id="filterSections">
        <!-- Filter sections will be generated here -->
      </div>
    </div>
    <div class="filter-resize-handle" id="filterResizeHandle"></div>
  </div>
  
  <div class="stats">
    <span>Total Events: <strong id="totalCount">0</strong></span>
    <span>Filtered: <strong id="filteredCount">0</strong></span>
    <span>Paused: <strong id="pausedStatus">No</strong></span>
  </div>
  
  <div class="event-log scrollbar" id="eventLog"></div>

  <script>
    let eventCount = 0;
    let filteredCount = 0;
    let isPaused = false;
    let selectedEventTypes = new Set(); // Track which event types are selected
    let events = [];
    const DEFAULT_EXCLUDED_EVENTS = new Set(['mousemove', 'mouseenter', 'mouseover', 'mouseout', 'mouseleave']);
    
    // Track last event for grouping consecutive events
    let lastEventItem = null;
    let lastEventType = null;
    let consecutiveCount = 0;
    
    // Track which modifier keys are currently pressed and their sides
    let activeModifiers = {
      shiftLeft: false,
      shiftRight: false,
      ctrlLeft: false,
      ctrlRight: false,
      altLeft: false,
      altRight: false,
      metaLeft: false,
      metaRight: false
    };
    
    const eventLog = document.getElementById('eventLog');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const filterPanel = document.getElementById('filterPanel');
    const filterPanelHeader = document.getElementById('filterPanelHeader');
    const filterPanelHeaderLeft = filterPanelHeader.querySelector('.filter-panel-header-left');
    const filterPanelToggle = document.getElementById('filterPanelToggle');
    const filterContent = document.getElementById('filterContent');
    const filterSections = document.getElementById('filterSections');
    const filterResizeHandle = document.getElementById('filterResizeHandle');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const selectNoneBtn = document.getElementById('selectNoneBtn');
    const exportBtn = document.getElementById('exportBtn');
    const totalCountEl = document.getElementById('totalCount');
    const filteredCountEl = document.getElementById('filteredCount');
    const pausedStatusEl = document.getElementById('pausedStatus');
    
    function formatTime() {
      const now = new Date();
      return now.toLocaleTimeString() + '.' + now.getMilliseconds().toString().padStart(3, '0');
    }
    
    function formatEventDetails(event) {
      let details = [];
      
      if (event.type) details.push(`Type: ${event.type}`);
      if (event.target) {
        const tag = event.target.tagName || 'Unknown';
        const id = event.target.id ? `#${event.target.id}` : '';
        const className = event.target.className ? `.${event.target.className.split(' ')[0]}` : '';
        details.push(`Target: ${tag}${id}${className}`);
      }
      if (event.key) {
        let keyInfo = `Key: ${event.key}`;
        if (event.code) {
          keyInfo += ` (code: ${event.code})`;
          // Show left/right distinction for modifier keys
          if (event.code.includes('Left')) keyInfo += ' [Left]';
          else if (event.code.includes('Right')) keyInfo += ' [Right]';
        } else if (event.keyCode) {
          keyInfo += ` (keyCode: ${event.keyCode})`;
        }
        details.push(keyInfo);
      }
      if (event.button !== undefined) details.push(`Button: ${event.button}`);
      if (event.clientX !== undefined) details.push(`Position: (${event.clientX}, ${event.clientY})`);
      if (event.deltaX !== undefined || event.deltaY !== undefined) {
        details.push(`Delta: (${event.deltaX || 0}, ${event.deltaY || 0})`);
      }
      if (event.touches) details.push(`Touches: ${event.touches.length}`);
      // Show which modifier keys are pressed with left/right distinction
      if (event.shiftKey) {
        let shiftInfo = 'Shift';
        if (activeModifiers.shiftLeft && activeModifiers.shiftRight) {
          shiftInfo += ' [Both]';
        } else if (activeModifiers.shiftLeft) {
          shiftInfo += ' [Left]';
        } else if (activeModifiers.shiftRight) {
          shiftInfo += ' [Right]';
        }
        details.push(shiftInfo);
      }
      if (event.ctrlKey) {
        let ctrlInfo = 'Ctrl';
        if (activeModifiers.ctrlLeft && activeModifiers.ctrlRight) {
          ctrlInfo += ' [Both]';
        } else if (activeModifiers.ctrlLeft) {
          ctrlInfo += ' [Left]';
        } else if (activeModifiers.ctrlRight) {
          ctrlInfo += ' [Right]';
        }
        details.push(ctrlInfo);
      }
      if (event.altKey) {
        let altInfo = 'Alt';
        if (activeModifiers.altLeft && activeModifiers.altRight) {
          altInfo += ' [Both]';
        } else if (activeModifiers.altLeft) {
          altInfo += ' [Left]';
        } else if (activeModifiers.altRight) {
          altInfo += ' [Right]';
        }
        details.push(altInfo);
      }
      if (event.metaKey) {
        let metaInfo = 'Meta';
        if (activeModifiers.metaLeft && activeModifiers.metaRight) {
          metaInfo += ' [Both]';
        } else if (activeModifiers.metaLeft) {
          metaInfo += ' [Left]';
        } else if (activeModifiers.metaRight) {
          metaInfo += ' [Right]';
        }
        details.push(metaInfo);
      }
      
      return details.length > 0 ? details.join(' | ') : 'No additional details';
    }

    function formatHumanTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      }) + '.' + date.getMilliseconds().toString().padStart(3, '0');
    }

    function describeNode(node) {
      if (!node) return null;
      if (typeof Window !== 'undefined' && node instanceof Window) return 'window';
      if (node === document) return 'document';
      if (typeof Node !== 'undefined' && node instanceof Node) {
        switch (node.nodeType) {
          case Node.TEXT_NODE:
            return '#text';
          case Node.COMMENT_NODE:
            return '#comment';
          case Node.DOCUMENT_NODE:
            return 'document';
          case Node.ELEMENT_NODE:
          default: {
            const element = node;
            const tag = element.tagName ? element.tagName.toLowerCase() : 'element';
            const id = element.id ? `#${element.id}` : '';
            const className = element.className && typeof element.className === 'string'
              ? `.${element.className.split(' ').filter(Boolean)[0] || ''}`
              : '';
            return `${tag}${id}${className}`;
          }
        }
      }
      return Object.prototype.toString.call(node);
    }

    function serializeTouchList(touchList) {
      if (!touchList) return undefined;
      try {
        return Array.from(touchList).map(touch => ({
          identifier: touch.identifier,
          clientX: touch.clientX,
          clientY: touch.clientY,
          pageX: touch.pageX,
          pageY: touch.pageY,
          screenX: touch.screenX,
          screenY: touch.screenY,
          radiusX: touch.radiusX,
          radiusY: touch.radiusY,
          rotationAngle: touch.rotationAngle,
          force: touch.force,
          target: describeNode(touch.target)
        }));
      } catch (err) {
        return `[Unserializable TouchList: ${err.message}]`;
      }
    }

    function assignIfDefined(target, key, value) {
      if (value !== undefined) {
        target[key] = value;
      }
    }

    function toSerializable(value, depth = 0, seen = new WeakSet()) {
      if (value === null || typeof value === 'undefined') return value;
      if (typeof value === 'function') return '[Function]';
      if (typeof value === 'symbol') return value.toString();

      if (typeof Window !== 'undefined' && value instanceof Window) return 'window';
      if (value === document) return 'document';
      if (typeof Node !== 'undefined' && value instanceof Node) {
        return describeNode(value);
      }

      if (typeof value !== 'object') return value;

      if (seen.has(value)) return '[Circular]';
      if (depth >= 2) {
        if (Array.isArray(value)) return `[Array(${value.length})]`;
        if (ArrayBuffer.isView && ArrayBuffer.isView(value)) return `[TypedArray(${value.length})]`;
        return '[Object]';
      }

      seen.add(value);

      if (Array.isArray(value)) {
        return value.slice(0, 20).map(item => {
          try {
            return toSerializable(item, depth + 1, seen);
          } catch (err) {
            return `[Unserializable: ${err.message}]`;
          }
        });
      }

      if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
        return Array.from(value).slice(0, 20);
      }

      const result = {};
      const keys = Object.keys(value).slice(0, 30);
      keys.forEach(key => {
        try {
          result[key] = toSerializable(value[key], depth + 1, seen);
        } catch (err) {
          result[key] = `[Unserializable: ${err.message}]`;
        }
      });

      return result;
    }

    function serializeEvent(event) {
      const snapshot = {
        type: event.type,
        timeStamp: event.timeStamp,
        isTrusted: event.isTrusted,
        eventPhase: event.eventPhase,
        bubbles: event.bubbles,
        cancelable: event.cancelable,
        composed: event.composed,
        defaultPrevented: event.defaultPrevented,
        target: describeNode(event.target),
        currentTarget: describeNode(event.currentTarget),
        relatedTarget: describeNode(event.relatedTarget),
        modifierKeys: {
          altKey: event.altKey,
          ctrlKey: event.ctrlKey,
          metaKey: event.metaKey,
          shiftKey: event.shiftKey
        },
        activeModifiers: { ...activeModifiers }
      };

      assignIfDefined(snapshot, 'detail', toSerializable(event.detail));
      assignIfDefined(snapshot, 'which', event.which);
      assignIfDefined(snapshot, 'button', event.button);
      assignIfDefined(snapshot, 'buttons', event.buttons);
      assignIfDefined(snapshot, 'clientX', event.clientX);
      assignIfDefined(snapshot, 'clientY', event.clientY);
      assignIfDefined(snapshot, 'pageX', event.pageX);
      assignIfDefined(snapshot, 'pageY', event.pageY);
      assignIfDefined(snapshot, 'screenX', event.screenX);
      assignIfDefined(snapshot, 'screenY', event.screenY);
      assignIfDefined(snapshot, 'offsetX', event.offsetX);
      assignIfDefined(snapshot, 'offsetY', event.offsetY);
      assignIfDefined(snapshot, 'movementX', event.movementX);
      assignIfDefined(snapshot, 'movementY', event.movementY);
      assignIfDefined(snapshot, 'key', event.key);
      assignIfDefined(snapshot, 'code', event.code);
      assignIfDefined(snapshot, 'keyCode', event.keyCode);
      assignIfDefined(snapshot, 'charCode', event.charCode);
      assignIfDefined(snapshot, 'location', event.location);
      assignIfDefined(snapshot, 'repeat', event.repeat);
      assignIfDefined(snapshot, 'propertyName', event.propertyName);
      assignIfDefined(snapshot, 'propertyNamespace', event.propertyNamespace);
      assignIfDefined(snapshot, 'state', toSerializable(event.state));
      assignIfDefined(snapshot, 'pointerId', event.pointerId);
      assignIfDefined(snapshot, 'pointerType', event.pointerType);
      assignIfDefined(snapshot, 'width', event.width);
      assignIfDefined(snapshot, 'height', event.height);
      assignIfDefined(snapshot, 'pressure', event.pressure);
      assignIfDefined(snapshot, 'tiltX', event.tiltX);
      assignIfDefined(snapshot, 'tiltY', event.tiltY);
      assignIfDefined(snapshot, 'twist', event.twist);
      assignIfDefined(snapshot, 'tangentialPressure', event.tangentialPressure);
      assignIfDefined(snapshot, 'deltaX', event.deltaX);
      assignIfDefined(snapshot, 'deltaY', event.deltaY);
      assignIfDefined(snapshot, 'deltaZ', event.deltaZ);
      assignIfDefined(snapshot, 'deltaMode', event.deltaMode);
      assignIfDefined(snapshot, 'data', toSerializable(event.data));
      assignIfDefined(snapshot, 'inputType', event.inputType);
      assignIfDefined(snapshot, 'isComposing', event.isComposing);
      assignIfDefined(snapshot, 'elapsedTime', event.elapsedTime);
      assignIfDefined(snapshot, 'animationName', event.animationName);
      assignIfDefined(snapshot, 'pseudoElement', event.pseudoElement);

      const touches = serializeTouchList(event.touches);
      if (touches) snapshot.touches = touches;
      const changedTouches = serializeTouchList(event.changedTouches);
      if (changedTouches) snapshot.changedTouches = changedTouches;
      const targetTouches = serializeTouchList(event.targetTouches);
      if (targetTouches) snapshot.targetTouches = targetTouches;

      if (typeof event.getModifierState === 'function') {
        try {
          snapshot.modifierState = {
            Alt: event.getModifierState('Alt'),
            AltGraph: event.getModifierState('AltGraph'),
            CapsLock: event.getModifierState('CapsLock'),
            Control: event.getModifierState('Control'),
            Meta: event.getModifierState('Meta'),
            NumLock: event.getModifierState('NumLock'),
            ScrollLock: event.getModifierState('ScrollLock'),
            Shift: event.getModifierState('Shift')
          };
        } catch (err) {
          snapshot.modifierStateError = err.message;
        }
      }

      const enumerableProps = {};
      Object.keys(event).forEach(key => {
        if (key in snapshot) return;
        try {
          enumerableProps[key] = toSerializable(event[key]);
        } catch (err) {
          enumerableProps[key] = `[Unserializable: ${err.message}]`;
        }
      });
      if (Object.keys(enumerableProps).length > 0) {
        snapshot.enumerableProperties = enumerableProps;
      }

      return snapshot;
    }

    function formatRawEventDetails(eventData) {
      try {
        const snapshot = serializeEvent(eventData.event);
        snapshot.capturedAt = formatHumanTimestamp(eventData.timestamp);
        snapshot.capturedEpoch = eventData.timestamp;
        snapshot.eventId = eventData.id;
        return JSON.stringify(snapshot, null, 2);
      } catch (err) {
        return `Unable to serialize event: ${err.message}`;
      }
    }

    function createEventItemElement(eventData) {
      const eventItem = document.createElement('div');
      eventItem.className = 'event-item';

      const header = document.createElement('div');
      header.className = 'event-item-header';

      const timeSpan = document.createElement('span');
      timeSpan.className = 'event-time';
      timeSpan.textContent = `[${formatHumanTimestamp(eventData.timestamp)}]`;

      const typeSpan = document.createElement('span');
      typeSpan.className = 'event-type';
      typeSpan.textContent = eventData.type;

      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'event-raw-toggle';
      toggleBtn.type = 'button';
      toggleBtn.textContent = 'Show raw';
      toggleBtn.setAttribute('aria-expanded', 'false');

      header.appendChild(timeSpan);
      header.appendChild(typeSpan);
      header.appendChild(toggleBtn);

      const detailsDiv = document.createElement('div');
      detailsDiv.className = 'event-details';
      detailsDiv.innerHTML = formatEventDetails(eventData.event);

      const rawWrapper = document.createElement('div');
      rawWrapper.className = 'event-raw';
      rawWrapper.hidden = true;

      const rawPre = document.createElement('pre');
      rawPre.textContent = formatRawEventDetails(eventData);
      rawWrapper.appendChild(rawPre);

      toggleBtn.addEventListener('click', () => {
        const willShow = rawWrapper.hidden;
        rawWrapper.hidden = !willShow;
        toggleBtn.textContent = willShow ? 'Hide raw' : 'Show raw';
        toggleBtn.setAttribute('aria-expanded', String(willShow));
        eventItem.classList.toggle('event-item-expanded', willShow);
      });

      eventItem.appendChild(header);
      eventItem.appendChild(detailsDiv);
      eventItem.appendChild(rawWrapper);

      eventItem.__rawPre = rawPre;

      return eventItem;
    }

    function updateEventItemElement(eventItem, eventData) {
      const timeSpan = eventItem.querySelector('.event-time');
      if (timeSpan) timeSpan.textContent = `[${formatHumanTimestamp(eventData.timestamp)}]`;

      const detailsDiv = eventItem.querySelector('.event-details');
      if (detailsDiv) detailsDiv.innerHTML = formatEventDetails(eventData.event);

      if (eventItem.__rawPre) {
        eventItem.__rawPre.textContent = formatRawEventDetails(eventData);
      }
    }
    
    function addEvent(event) {
      if (isPaused) return;
      
      // Track modifier key states for left/right distinction
      if (event.type === 'keydown' || event.type === 'keyup') {
        const isPressed = event.type === 'keydown';
        if (event.code === 'ShiftLeft') activeModifiers.shiftLeft = isPressed;
        else if (event.code === 'ShiftRight') activeModifiers.shiftRight = isPressed;
        else if (event.code === 'ControlLeft') activeModifiers.ctrlLeft = isPressed;
        else if (event.code === 'ControlRight') activeModifiers.ctrlRight = isPressed;
        else if (event.code === 'AltLeft') activeModifiers.altLeft = isPressed;
        else if (event.code === 'AltRight') activeModifiers.altRight = isPressed;
        else if (event.code === 'MetaLeft') activeModifiers.metaLeft = isPressed;
        else if (event.code === 'MetaRight') activeModifiers.metaRight = isPressed;
      }
      
      eventCount++;
      const eventData = {
        id: eventCount,
        time: formatTime(),
        type: event.type,
        event: event,
        timestamp: Date.now()
      };
      
      events.push(eventData);
      
      // Apply checkbox filter (only show selected event types)
      // If no types are selected, show nothing. If types are selected, only show those.
      if (selectedEventTypes.size === 0 || !selectedEventTypes.has(event.type.toLowerCase())) {
        filteredCount++;
        // Reset grouping when event is filtered out
        lastEventItem = null;
        lastEventType = null;
        consecutiveCount = 0;
        updateStats();
        return;
      }
      
      // Check if this is the same event type as the last one
      const isSameType = lastEventType === event.type && lastEventItem !== null;
      
      if (isSameType) {
        // Update the existing event item with new count and details
        consecutiveCount++;
        updateEventItemElement(lastEventItem, eventData);
        
        // Find and update the count badge
        let countBadge = lastEventItem.querySelector('.event-count-badge');
        if (!countBadge) {
          // Create count badge if it doesn't exist
          countBadge = document.createElement('span');
          countBadge.className = 'event-count-badge';
          const eventTypeSpan = lastEventItem.querySelector('.event-type');
          if (eventTypeSpan) {
            eventTypeSpan.parentNode.insertBefore(countBadge, eventTypeSpan.nextSibling);
          }
          lastEventItem.classList.add('event-item-grouped');
        }
        countBadge.textContent = `x${consecutiveCount + 1}`;
      } else {
        // Create a new event item
        consecutiveCount = 0;
        lastEventType = event.type;

        const eventItem = createEventItemElement(eventData);

        // Add at the top of the log
        const firstChild = eventLog.firstChild;
        if (firstChild) {
          eventLog.insertBefore(eventItem, firstChild);
        } else {
          eventLog.appendChild(eventItem);
        }
        
        lastEventItem = eventItem;
      }
      
      // Keep scroll position at top when new events are added
      // Only auto-scroll to top if user is already at the top (within 10px)
      const isNearTop = eventLog.scrollTop < 10;
      if (isNearTop) {
        eventLog.scrollTop = 0;
      }
      
      updateStats();
    }
    
    function updateStats() {
      totalCountEl.textContent = eventCount;
      filteredCountEl.textContent = filteredCount;
      pausedStatusEl.textContent = isPaused ? 'Yes' : 'No';
    }
    
    function clearLog() {
      eventLog.innerHTML = '';
      events = [];
      eventCount = 0;
      filteredCount = 0;
      // Reset grouping
      lastEventItem = null;
      lastEventType = null;
      consecutiveCount = 0;
      updateStats();
    }
    
    function togglePause() {
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
      pauseBtn.classList.toggle('active', isPaused);
      updateStats();
    }
    
    function applyFilter() {
      eventLog.innerHTML = '';
      filteredCount = 0;
      
      // Reset grouping when applying filter
      lastEventItem = null;
      lastEventType = null;
      consecutiveCount = 0;
      
      // Process events in reverse order (newest first) to maintain top-to-bottom display
      const eventsToShow = [];
      for (let i = events.length - 1; i >= 0; i--) {
        const eventData = events[i];
        
        // Apply checkbox filter (only show selected event types)
        // If no types are selected, show nothing. If types are selected, only show those.
        if (selectedEventTypes.size === 0 || !selectedEventTypes.has(eventData.type.toLowerCase())) {
          filteredCount++;
          continue;
        }
        
        eventsToShow.push(eventData);
      }
      
      // Group consecutive events of the same type
      let currentGroup = null;
      
      eventsToShow.forEach((eventData) => {
        const isSameAsPrevious = currentGroup !== null && 
                                  currentGroup.type === eventData.type;
        
        if (isSameAsPrevious) {
          currentGroup.count += 1;
          updateEventItemElement(currentGroup.item, eventData);

          let countBadge = currentGroup.item.querySelector('.event-count-badge');
          if (!countBadge) {
            countBadge = document.createElement('span');
            countBadge.className = 'event-count-badge';
            const eventTypeSpan = currentGroup.item.querySelector('.event-type');
            if (eventTypeSpan) {
              eventTypeSpan.parentNode.insertBefore(countBadge, eventTypeSpan.nextSibling);
            }
            currentGroup.item.classList.add('event-item-grouped');
          }
          countBadge.textContent = `x${currentGroup.count + 1}`;
        } else {
          const eventItem = createEventItemElement(eventData);
          eventLog.appendChild(eventItem);
          
          currentGroup = {
            type: eventData.type,
            item: eventItem,
            count: 0
          };
        }
      });
      
      eventLog.scrollTop = 0;
      updateStats();
    }
    
    function exportLog() {
      // Export all events (newest first)
      const date = new Date();
      const logText = events
        .slice()
        .reverse() // Reverse to show newest first
        .map(e => {
          const eventDate = new Date(e.timestamp);
          const humanTime = eventDate.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          }) + '.' + eventDate.getMilliseconds().toString().padStart(3, '0');
          return `[${humanTime}] ${e.type} - ${formatEventDetails(e.event)}`;
        }).join('\n');
      
      const blob = new Blob([logText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `js-events-${Date.now()}.txt`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    // Initialize filter checkboxes organized by sections
    function initializeFilterCheckboxes() {
      const eventSections = [
        {
          title: 'Mouse Events',
          events: ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseenter', 
                   'mouseleave', 'mouseover', 'mouseout', 'contextmenu']
        },
        {
          title: 'Touch Events',
          events: ['touchstart', 'touchend', 'touchmove', 'touchcancel']
        },
        {
          title: 'Keyboard Events',
          events: ['keydown', 'keyup', 'keypress']
        },
        {
          title: 'Form Events',
          events: ['input', 'change', 'submit', 'reset', 'focus', 'blur', 'select']
        },
        {
          title: 'Window Events',
          events: ['load', 'unload', 'beforeunload', 'resize', 'scroll', 'hashchange',
                   'popstate', 'pageshow', 'pagehide']
        },
        {
          title: 'Media Events',
          events: ['play', 'pause', 'ended', 'timeupdate', 'volumechange']
        },
        {
          title: 'Drag & Drop',
          events: ['drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop']
        },
        {
          title: 'Clipboard',
          events: ['copy', 'cut', 'paste']
        },
        {
          title: 'Other',
          events: ['wheel', 'error', 'online', 'offline', 'visibilitychange', 'focusin', 'focusout']
        }
      ];
      
      eventSections.forEach((section, sectionIndex) => {
        const sectionEl = document.createElement('div');
        sectionEl.className = 'filter-section expanded';
        sectionEl.dataset.sectionIndex = sectionIndex;
        
        const header = document.createElement('div');
        header.className = 'filter-section-header';
        
        const headerLeft = document.createElement('div');
        headerLeft.className = 'filter-section-header-left';
        
        const title = document.createElement('h4');
        title.textContent = section.title;
        
        const toggle = document.createElement('span');
        toggle.className = 'filter-section-toggle';
        toggle.textContent = '▼';
        
        headerLeft.appendChild(title);
        headerLeft.appendChild(toggle);
        
        const sectionActions = document.createElement('div');
        sectionActions.className = 'filter-section-actions';
        
        const enableAllBtn = document.createElement('button');
        enableAllBtn.className = 'filter-section-action-btn';
        enableAllBtn.textContent = 'Enable All';
        enableAllBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          section.events.forEach(eventType => {
            const checkbox = document.getElementById(`filter-${eventType}`);
            if (checkbox && !checkbox.checked) {
              checkbox.checked = true;
              selectedEventTypes.add(eventType.toLowerCase());
            }
          });
          applyFilter();
        });
        
        const disableAllBtn = document.createElement('button');
        disableAllBtn.className = 'filter-section-action-btn';
        disableAllBtn.textContent = 'Disable All';
        disableAllBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          section.events.forEach(eventType => {
            const checkbox = document.getElementById(`filter-${eventType}`);
            if (checkbox && checkbox.checked) {
              checkbox.checked = false;
              selectedEventTypes.delete(eventType.toLowerCase());
            }
          });
          applyFilter();
        });
        
        sectionActions.appendChild(enableAllBtn);
        sectionActions.appendChild(disableAllBtn);
        
        header.appendChild(headerLeft);
        header.appendChild(sectionActions);
        
        headerLeft.addEventListener('click', () => {
          sectionEl.classList.toggle('expanded');
          toggle.textContent = sectionEl.classList.contains('expanded') ? '▼' : '▶';
        });
        
        const content = document.createElement('div');
        content.className = 'filter-section-content';
        
        section.events.forEach(eventType => {
          const item = document.createElement('div');
          item.className = 'filter-checkbox-item';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `filter-${eventType}`;
          checkbox.value = eventType;
          const eventKey = eventType.toLowerCase();
          const isExcluded = DEFAULT_EXCLUDED_EVENTS.has(eventKey);
          checkbox.checked = !isExcluded;
          checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
              selectedEventTypes.add(eventKey);
            } else {
              selectedEventTypes.delete(eventKey);
            }
            applyFilter();
          });
          
          const label = document.createElement('label');
          label.htmlFor = `filter-${eventType}`;
          label.textContent = eventType;
          
          item.appendChild(checkbox);
          item.appendChild(label);
          content.appendChild(item);
          
          // Add to selected set by default
          if (!isExcluded) {
            selectedEventTypes.add(eventKey);
          }
        });
        
        sectionEl.appendChild(header);
        sectionEl.appendChild(content);
        filterSections.appendChild(sectionEl);
      });
    }
    
    function toggleFilterPanel() {
      filterPanel.classList.toggle('collapsed');
      filterPanelToggle.textContent = filterPanel.classList.contains('collapsed') ? '▶' : '▼';
    }
    
    function selectAllEvents() {
      const checkboxes = filterSections.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => {
        cb.checked = true;
        selectedEventTypes.add(cb.value.toLowerCase());
      });
      applyFilter();
    }
    
    function selectNoneEvents() {
      const checkboxes = filterSections.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => {
        cb.checked = false;
        selectedEventTypes.delete(cb.value.toLowerCase());
      });
      applyFilter();
    }
    
    // Event listeners
    clearBtn.addEventListener('click', clearLog);
    pauseBtn.addEventListener('click', togglePause);
    filterPanelHeaderLeft.addEventListener('click', () => {
      toggleFilterPanel();
    });
    selectAllBtn.addEventListener('click', selectAllEvents);
    selectNoneBtn.addEventListener('click', selectNoneEvents);
    exportBtn.addEventListener('click', exportLog);
    
    // Resize handle functionality
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;
    
    filterResizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startY = e.clientY;
      startHeight = filterPanel.offsetHeight;
      document.body.style.cursor = 'ns-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const deltaY = e.clientY - startY;
      const maxHeight = Math.round(window.innerHeight * 0.70); // 70% of viewport height
      const newHeight = Math.max(200, Math.min(maxHeight, startHeight + deltaY));
      filterPanel.style.height = `${newHeight}px`;
      filterPanel.style.maxHeight = 'none';
      e.preventDefault();
    });
    
    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
      }
    });
    
    // Update max height on window resize if panel has been manually resized
    window.addEventListener('resize', () => {
      if (filterPanel.style.height && filterPanel.style.height !== '') {
        const maxHeight = Math.round(window.innerHeight * 0.70);
        const currentHeight = parseInt(filterPanel.style.height);
        if (currentHeight > maxHeight) {
          filterPanel.style.height = `${maxHeight}px`;
        }
      }
    });
    
    // Initialize filter checkboxes
    initializeFilterCheckboxes();
    
    // Capture all JavaScript events
    const eventTypes = [
      // Mouse events
      'click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseenter', 
      'mouseleave', 'mouseover', 'mouseout', 'contextmenu',
      
      // Touch events
      'touchstart', 'touchend', 'touchmove', 'touchcancel',
      
      // Keyboard events
      'keydown', 'keyup', 'keypress',
      
      // Form events
      'input', 'change', 'submit', 'reset', 'focus', 'blur', 'select',
      
      // Window events
      'load', 'unload', 'beforeunload', 'resize', 'scroll', 'hashchange',
      'popstate', 'pageshow', 'pagehide',
      
      // Media events
      'play', 'pause', 'ended', 'timeupdate', 'volumechange',
      
      // Drag and drop
      'drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop',
      
      // Clipboard
      'copy', 'cut', 'paste',
      
      // Other
      'wheel', 'error', 'online', 'offline', 'visibilitychange', 'focusin', 'focusout'
    ];
    
    // Add event listeners to document (capture phase)
    eventTypes.forEach(eventType => {
      try {
        document.addEventListener(eventType, (e) => {
          addEvent(e);
        }, { capture: true, passive: true });
      } catch (err) {
        console.warn(`Failed to add listener for ${eventType}:`, err);
      }
    });
    
    // Add event listeners to window for window-specific events
    const windowEventTypes = ['resize', 'scroll', 'focus', 'blur', 'hashchange', 'popstate', 
                              'load', 'unload', 'beforeunload', 'online', 'offline', 'error'];
    windowEventTypes.forEach(eventType => {
      try {
        window.addEventListener(eventType, (e) => {
          addEvent(e);
        }, { capture: true, passive: true });
      } catch (err) {
        console.warn(`Failed to add window listener for ${eventType}:`, err);
      }
    });
    
    // Also add to body for better coverage
    if (document.body) {
      eventTypes.forEach(eventType => {
        try {
          document.body.addEventListener(eventType, (e) => {
            addEvent(e);
          }, { capture: true, passive: true });
        } catch (err) {
          // Ignore errors for body listeners
        }
      });
    }
    
    // Wait for body to be ready if not already
    if (!document.body) {
      document.addEventListener('DOMContentLoaded', () => {
        eventTypes.forEach(eventType => {
          try {
            document.body.addEventListener(eventType, (e) => {
              addEvent(e);
            }, { capture: true, passive: true });
          } catch (err) {
            // Ignore errors
          }
        });
      });
    }
    
    // Initial stats
    updateStats();
    
    // Add welcome message
    setTimeout(() => {
      const welcome = document.createElement('div');
      welcome.className = 'event-item';
      welcome.style.borderLeftColor = '#4CAF50';
      const listenerCount = eventTypes.length * 2 + windowEventTypes.length; // document + body + window
      const now = new Date();
      const humanTime = now.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      }) + '.' + now.getMilliseconds().toString().padStart(3, '0');
      welcome.innerHTML = `
        <span class="event-time">[${humanTime}]</span>
        <span class="event-type">SYSTEM</span>
        <div class="event-details">Event monitor initialized. ${listenerCount} event listeners registered. All JavaScript events will be logged here. Try clicking, typing, or using the "Test Events" button.</div>
      `;
      eventLog.appendChild(welcome);
      
      // Log to console for debugging
      console.log('Event monitor initialized with', listenerCount, 'listeners');
      console.log('Selected event types:', Array.from(selectedEventTypes));
    }, 100);
  </script>
</body>
</html>


